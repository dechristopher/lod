// This file is automatically generated. DO NOT EDIT.

package geos

// #include "geos.h"
import "C"

{{ range . }}

{{   if (eq .type "unary") }}
{{     $geosFunction := printf "GEOS%s_r" .name }}
{{     if .geosFunction }}
{{       $geosFunction = .geosFunction }}
{{     end }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}() *Geom {
    g.mustNotBeDestroyed()
    g.context.Lock()
    defer g.context.Unlock()
    return g.context.newNonNilGeom(C.{{ $geosFunction }}(g.context.handle, g.geom), nil)
}

{{   else if (eq .type "binary") }}
{{     $geosFunction := printf "GEOS%s_r" .name }}
{{     if .geosFunction }}
{{       $geosFunction = .geosFunction }}
{{     end }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) *Geom {
    g.mustNotBeDestroyed()
    g.context.Lock()
    defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
    return g.context.newGeom(C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}), nil)
}

{{   else if (eq .type "unaryPredicate") }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOS{{ .name | replaceAllRegexp "^I" "i" }}_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

{{   else if (eq .type "binaryPredicate") }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
	switch C.GEOS{{ .name }}_r(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

{{   else if (eq .type "float64Property") }}
{{     $geosFunction := printf "GEOS%s_r" .name }}
{{     if .geosFunction }}
{{       $geosFunction = .geosFunction }}
{{     end }}
{{     $varName := .name | firstRuneToLower }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var {{ $varName }} float64
    if C.{{ $geosFunction }}(g.context.handle, g.geom, (*C.double)(&{{ $varName }})) == 0 {
		panic(g.context.err)
	}
	return {{ $varName }}
}

{{   else if (eq .type "float64BinaryProperty") }}
{{     $geosFunction := printf "GEOS%s_r" .name }}
{{     if .geosFunction }}
{{       $geosFunction = .geosFunction }}
{{     end }}
{{     $varName := .name | firstRuneToLower }}

// {{ .name }} {{ .comment }}.
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
	var {{ $varName }} float64
	if C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}, (*C.double)(&{{ $varName }})) == 0 {
		panic(g.context.err)
	}
	return {{ $varName }}
}

{{   end }}

{{ end }}